## VM design (Minimal prototype)

This document describes a minimal VM design and a basic heap/object system used as a runtime for bytecode generated by the `compiler`.

Goals:
- Provide a small object model for runtime values (integers, booleans, None, arrays, code/function refs and strings)
- Provide a simple heap that tracks runtime objects and provides conversion from compile-time `Value` constants
- Implement a minimal stack-based VM that executes the project's `bytecode` format for a subset of opcodes

Structure:
- `src/runtime/vm/object.h` / `object.c` — defines `Object` runtime value (type-tagged union), with reference counting helpers
- `src/runtime/vm/heap.h` / `heap.c` — provides a `Heap` abstraction that creates and tracks runtime objects and converts compile-time `Value` to runtime `Object*`
- `src/runtime/vm/vm.h` / `vm.c` — provides a tiny interpreter that executes `CodeObj` objects generated by the `compiler`

Supported objects (initial):
- OBJ_INT — 64-bit int
- OBJ_BOOL — bool
- OBJ_NONE — None object
- OBJ_ARRAY — dynamic array (object references)
- OBJ_FUNCTION — reference to a `CodeObj` (compiler representation of a function body)

Supported bytecodes (subset):
- LOAD_CONST, LOAD_FAST, STORE_FAST
- LOAD_GLOBAL, STORE_GLOBAL
- BINARY_OP (ADD, SUB, MUL, DIV for integers)
- PUSH_NULL, POP_TOP
- MAKE_FUNCTION, CALL_FUNCTION (basic function creation and invocation)
- RETURN_VALUE

Notes and limitations:
- The VM uses reference counting for object lifetime; this is a simple approach that works for a prototype but cannot handle cycles.
- Globals are represented as an array (`vm->globals`) sized by the caller when creating the VM; the compiler currently uses numeric indices for global names.
- The VM is minimal; many features and type cases are still stubs. Use it as a starting point for building the runtime and adding more opcodes, GC, str/array manipulation, closures, and builtins.

How to use the simple VM (example outline):
1. Create the `Heap` with `heap_create()`.
2. Allocate or convert constants into runtime objects using `heap_from_value()` or heap alloc helpers.
3. Create a `VM` with `vm_create(heap, global_count)`.
4. Call `vm_execute(vm, code_obj)` where `code_obj` is built by the compiler (see `CodeObj` created in `compiler.c`).

Future work (recommended):
- Implement real GC (mark-and-sweep) in `runtime/gc` and integrate it into the `Heap`.
- Add builtins for I/O (print), arrays, strings, and function closures.
- Improve value types: strings, floats, and custom object slots.
- Wire global name mapping from compiler to runtime (serialize mapping alongside compiled bytecode or export metadata).
