# Virtual Machine Design Documentation

## Overview
This document describes the Virtual Machine (VM) and runtime system for executing bytecode generated by the compiler. The VM provides a stack-based interpreter with a garbage-collected heap for managing runtime objects.

## Architecture

### 1. Core Components

#### 1.1 Virtual Machine (VM)
The VM is the central execution engine that manages:
- **Stack frames** for function execution
- **Global variables** storage
- **Object pools** and memory management
- **Garbage collection** integration
- **JIT compilation** support

#### 1.2 Object System
The object system provides runtime representation of values with type tagging:

```c
typedef enum {
    OBJ_INT,           // 64-bit integers
    OBJ_BOOL,          // Boolean values
    OBJ_NONE,          // None/null value
    OBJ_CODE,          // Code objects (compiled functions)
    OBJ_FUNCTION,      // Function objects (wrapping code)
    OBJ_ARRAY,         // Dynamic arrays
    OBJ_NATIVE_FUNCTION, // C-native functions
    OBJ_FLOAT,         // Arbitrary-precision floating point
} ObjectType;
```

#### 1.3 Heap Management
The heap uses object pools for efficient allocation:
- **Pool-based allocation** with bump-pointer allocation
- **Integer caching** for commonly used values (-1M to +1M)
- **Singleton objects** for None, True, False
- **Memory blocks** organized by object type

### 2. Execution Model

#### 2.1 Stack Frame Structure
```c
struct Frame {
    VM* vm;                  // Reference to VM
    CodeObj* code;           // Current code object
    Object** locals;         // Local variables array
    size_t local_count;      // Number of locals
    Object** stack;          // Evaluation stack
    size_t stack_size;       // Current stack size
    size_t stack_capacity;   // Stack capacity
    size_t ip;               // Instruction pointer
};
```

#### 2.2 Evaluation Stack
- **Grows upwards** from lower addresses
- **Contains Object pointers**
- **Managed per frame** for function calls
- **Dynamic resizing** as needed

#### 2.3 Instruction Execution
```
while (frame->ip < code_length) {
    bytecode bc = code[frame->ip++];
    uint32_t arg = extract_argument(bc);
    
    switch (bc.op_code) {
        case LOAD_CONST:  // Load constant
        case LOAD_FAST:   // Load local variable
        case BINARY_OP:   // Binary operation
        // ... other instructions
    }
}
```

### 3. Object Types and Operations

#### 3.1 Integer Objects
- **64-bit signed integers**
- **Cached range**: -1,000,000 to +1,000,000
- **Direct value storage** (no heap allocation for cached values)

#### 3.2 Float Objects
- **Arbitrary-precision** using BigFloat
- **String-based storage** for exact representation
- **Operations**: add, subtract, multiply, divide, compare

#### 3.3 Boolean Objects
- **Singleton objects**: True, False
- **Immutable** with infinite reference count
- **Automatic truthiness** conversion

#### 3.4 Array Objects
- **Dynamic arrays** of Object pointers
- **Bounds checking** on access
- **Automatic resizing** for appends
- **Reference counting** for elements

#### 3.5 Function Objects
- **User-defined functions**: wrap CodeObj
- **Native functions**: C function pointers
- **Uniform calling convention**

#### 3.6 Code Objects
```c
typedef struct CodeObj {
    bytecode_array code;     // Compiled bytecode
    char* name;              // Function name
    uint8_t arg_count;       // Parameter count
    uint8_t local_count;     // Local variable count
    Value* constants;        // Constant pool
    size_t constants_count;  // Constant count
} CodeObj;
```

### 4. Instruction Set Implementation

#### 4.1 Load and Store Instructions

| Instruction | Description | Implementation |
|-------------|-------------|----------------|
| `LOAD_CONST` | Load constant from pool | Direct pool access |
| `LOAD_FAST` | Load local variable | Array indexing |
| `STORE_FAST` | Store to local | Array assignment |
| `LOAD_GLOBAL` | Load global variable | Global array indexing |
| `STORE_GLOBAL` | Store to global | Global array assignment |

#### 4.2 Arithmetic Instructions

| Instruction | Operations | Type Support |
|-------------|------------|--------------|
| `BINARY_OP` | +, -, *, /, %, ==, !=, <, <=, >, >=, is, and, or | int, float, bool |
| `UNARY_OP` | +, -, not | int, float, bool |

#### 4.3 Control Flow Instructions

| Instruction | Description | Argument |
|-------------|-------------|----------|
| `JUMP_FORWARD` | Jump forward | Offset in instructions |
| `JUMP_BACKWARD` | Jump backward (with interrupt check) | Offset |
| `POP_JUMP_IF_FALSE` | Conditional jump if false | Offset |
| `POP_JUMP_IF_TRUE` | Conditional jump if true | Offset |
| `LOOP_START` | Mark loop start | None |
| `LOOP_END` | Mark loop end | None |
| `BREAK_LOOP` | Break from loop | None |
| `CONTINUE_LOOP` | Continue loop iteration | None |

#### 4.4 Function Instructions

| Instruction | Description | Stack Effect |
|-------------|-------------|--------------|
| `MAKE_FUNCTION` | Create function from code | [code] → [func] |
| `CALL_FUNCTION` | Call function | [func, null, args...] → [result] |
| `PUSH_NULL` | Push null sentinel | [] → [null] |
| `RETURN_VALUE` | Return from function | [value] → (return) |

#### 4.5 Array Instructions

| Instruction | Description | Stack Effect |
|-------------|-------------|--------------|
| `BUILD_ARRAY` | Build array from stack | [elements...] → [array] |
| `LOAD_SUBSCR` | Load array element | [array, index] → [element] |
| `STORE_SUBSCR` | Store to array element | [value, array, index] → [] |
| `DEL_SUBSCR` | Delete array element | [array, index] → [] |

### 5. Memory Management

#### 5.1 Reference Counting
- **Automatic reference counting** for all objects
- **Infinite count** (0x7FFFFFFF) for immortal objects
- **Cycle detection** not implemented (future GC)

#### 5.2 Object Pools

```c
typedef struct ObjectPool {
    MemoryBlock* first;       // First memory block
    MemoryBlock* current;     // Current block for allocation
    size_t block_size;        // Objects per block
    size_t total_allocations; // Total allocations
} ObjectPool;
```

#### 5.3 Allocation Strategy
1. **Check cache** for integers in range
2. **Use bump-pointer** in current memory block
3. **Allocate new block** if current is full
4. **Initialize object** with zeroed memory

### 6. Built-in Functions

#### 6.1 Native Functions
```c
typedef Object* (*NativeCFunc)(VM* heap, int arg_count, Object** args);
```

#### 6.2 Provided Built-ins
- `print` - Output to console
- `input` - Read from console (stub)
- `randint` - Generate random integer
- `sqrt` - Square root (BigFloat)

### 7. Error Handling

#### 7.1 Runtime Errors
- **Array bounds checking**
- **Type checking** for operations
- **Division by zero** detection
- **Stack overflow/underflow**

#### 7.2 Debug Support
- **Instruction tracing** (when debug enabled)
- **Stack state inspection**
- **Object reference counting** tracking

### 8. Performance Optimizations

#### 8.1 Integer Caching
```c
#define INT_CACHE_MIN -1000000
#define INT_CACHE_MAX 1000000
Object* int_cache[INT_CACHE_SIZE];
```

#### 8.2 Fast Paths
- **Integer operations** using native CPU arithmetic
- **Direct pointer comparisons** for identity
- **Inline macro expansion** for common operations

#### 8.3 Stack Operations
```c
#define FAST_PUSH_GC(frame, obj)     // Push with GC increment
#define FAST_POP_NO_GC(frame)        // Pop without GC decrement
#define FAST_PEEK(frame, offset)     // Peek without popping
```

### 9. Execution Example

#### 9.1 Simple Program
```
// Source: x = 10 + 20
LOAD_CONST     0   # 10
LOAD_CONST     1   # 20
BINARY_OP     0x00 # +
STORE_FAST     0   # Store in x
RETURN_VALUE       # Return x
```

#### 9.2 Function Call
```
// Source: print("Hello")
LOAD_GLOBAL    0   # print function
PUSH_NULL         # null sentinel
LOAD_CONST     0   # "Hello" string
CALL_FUNCTION  1   # Call with 1 arg
POP_TOP          # Discard return value
```

### 10. Integration Points

#### 10.1 With Compiler
- **Constant pool** sharing
- **Global variable indices** alignment
- **Code object structure** compatibility

#### 10.2 With Garbage Collector
- **Reference counting** hooks
- **Root set** registration
- **Object finalization**

#### 10.3 With JIT Compiler
- **Hot spot detection**
- **Native code generation**
- **Fallback to interpreter**

### 11. Configuration Options

#### 11.1 Debug Mode
```c
#define DEBUG_ENABLED 1  // Enable debug output
#define TRACE_EXECUTION 0 // Trace each instruction
```

#### 11.2 Memory Settings
```c
#define INT_CACHE_MIN -1000000
#define INT_CACHE_MAX 1000000
#define DEFAULT_BLOCK_SIZE 1000
```

### 12. Future Extensions

#### 12.1 Planned Features
- **String type** support
- **Dictionary/Map** objects
- **Exception handling**
- **Module system**

#### 12.2 Performance Improvements
- **Just-In-Time compilation**
- **Optimized bytecode dispatch**
- **Memory pooling** enhancements
- **Parallel execution** support

---

## Appendix A: Bytecode Format

### Instruction Layout
```
opcode (1 byte) | argument (3 bytes)
```

### Argument Interpretation
- **0x01-0x07**: Local/global variable indices
- **0x08-0x0C**: Operator codes
- **0x0D-0x1F**: Control flow offsets
- **0x20-0xFF**: Special operations

## Appendix B: Object Lifecycle

### Creation
1. **Check cache** for common values
2. **Allocate from pool** using bump pointer
3. **Initialize fields** and type tag
4. **Set reference count** to 1

### Usage
1. **Increment refcount** when referenced
2. **Decrement refcount** when unreferenced
3. **Immediate free** if count reaches 0

### Destruction
1. **Type-specific cleanup** (arrays, strings)
2. **Return to pool** for reuse
3. **Memory block** recycling

## Appendix C: Debugging Support

### Runtime Inspection
```c
// Print object representation
char* str = object_to_string(obj);
printf("%s\n", str);
free(str);

// Check object truthiness
bool is_true = object_is_truthy(obj);

// Get object type
ObjectType type = obj->type;
```

### VM Statistics
```c
// Print heap statistics
heap_print_stats(vm->heap);

// Count live objects
size_t live = heap_live_objects(vm->heap);
```

---

*This VM provides a complete runtime environment for executing the language's bytecode with efficient memory management and comprehensive debugging support.*
