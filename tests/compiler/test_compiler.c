#include "../../src/compiler/compiler.h"
#include "../../src/AST/ast.h"
#include "../../src/lexer/token.h"
#include "../../src/system.h"
#include "../builtins/builtins.h"
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

void test_compiler_creation_and_destruction() {
    printf("=== Test: Compiler Creation and Destruction ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* literal = ast_new_literal_expression(loc, TYPE_INT, 5);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, literal);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    
    // Act
    compiler* comp = compiler_create(block_stmt);
    
    // Assert
    assert(comp != NULL);
    assert(comp->ast_tree == block_stmt);
    assert(comp->result != NULL);
    assert(comp->result->code_array.bytecodes == NULL);
    assert(comp->result->code_array.count == 0);
    assert(comp->result->code_array.capacity == 0);
    printf("✓ Compiler created successfully\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Compiler destroyed successfully\n\n");
}

void test_compile_literal_expression() {
    printf("=== Test: Compile Literal Expression ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* literal = ast_new_literal_expression(loc, TYPE_INT, 42);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, literal);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.count > 0);
    assert(result->code_array.bytecodes != NULL);
    assert(result->constants_count > 0);
    printf("✓ Compilation completed successfully\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    printf("✓ Constants pool size: %zu\n", result->constants_count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            has_load_const = true;
            uint32_t const_index = bytecode_get_arg(bc);
            printf("  LOAD_CONST found with const_index=%u\n", const_index);
            assert(const_index < result->constants_count);
        }
    }
    
    assert(has_load_const);
    printf("✓ Contains LOAD_CONST instruction\n");
    
    assert(result->constants_count >= 1);
    assert(result->constants[0].type == VAL_INT);
    assert(result->constants[0].int_val == 42);
    printf("✓ Constant value is correct: %lld\n", result->constants[0].int_val);
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_bool_literal() {
    printf("=== Test: Compile Bool Literal ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* literal = ast_new_literal_expression(loc, TYPE_BOOL, true);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, literal);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->constants_count >= 1);
    assert(result->constants[0].type == VAL_BOOL);
    assert(result->constants[0].bool_val == true);
    printf("✓ Boolean constant value is correct: %s\n", 
           result->constants[0].bool_val ? "true" : "false");
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            has_load_const = true;
            uint32_t const_index = bytecode_get_arg(bc);
            assert(const_index < result->constants_count);
            assert(result->constants[const_index].type == VAL_BOOL);
            assert(result->constants[const_index].bool_val == true);
        }
    }
    assert(has_load_const);
    printf("✓ Contains correct LOAD_CONST instruction for boolean\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_empty_block() {
    printf("=== Test: Compile Empty Block ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* statements[] = {};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 0);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    printf("✓ Empty block compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    printf("✓ Constants pool size: %zu\n", result->constants_count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    if (result->code_array.count == 0) {
        printf("✓ No bytecode generated (as expected for empty block)\n");
    }
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_null_safety() {
    printf("=== Test: Null Safety ===\n");
    
    // Act & Assert
    compiler* null_comp = compiler_create(NULL);
    assert(null_comp == NULL);
    printf("✓ compiler_create(NULL) returns NULL\n");
    
    compiler_destroy(NULL);
    printf("✓ compiler_destroy(NULL) is safe\n");
    
    compilation_result* null_result = compiler_compile(NULL);
    assert(null_result == NULL);
    printf("✓ compiler_compile(NULL) returns NULL\n");
    
    printf("✓ Null safety test completed successfully\n\n");
}

void test_bytecode_integrity() {
    printf("=== Test: Bytecode Integrity ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* literal = ast_new_literal_expression(loc, TYPE_INT, 123);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, literal);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        printf("  Bytecode[%u]: op_code=%u\n", i, bc.op_code);
        
        assert(bc.op_code <= 255);
        assert(bc.op_code == LOAD_CONST);
    }
    
    printf("✓ All bytecode instructions have valid op_codes\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Bytecode integrity test completed successfully\n\n");
}

void test_compile_variable_expression_no_such_var(){
    printf("=== Test: compile variable expr no such var ===\n");
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* variable = ast_new_variable_expression(loc, "x");
    ASTNode* expression_stmt = ast_new_expression_statement(loc, variable);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);

    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.bytecodes[0].op_code == NOP);

    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ compile variable expr test completed successfully\n\n");
}

void test_compile_variable_expression(){
    printf("=== Test: compile variable expr ===\n");
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* assign = ast_new_variable_declaration_statement(loc, TYPE_INT, "x", ast_new_literal_expression(loc, TYPE_INT, 5));

    ASTNode* variable = ast_new_variable_expression(loc, "x");
    ASTNode* expression_stmt = ast_new_expression_statement(loc, variable);

    ASTNode* statements[] = {assign, expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 2);
    compiler* comp = compiler_create(block_stmt);

    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 1);
    assert(result->code_array.bytecodes[0].op_code != NOP);

    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ compile variable expr test completed successfully\n\n");
}

void test_compile_binary_expression_plus() {
    printf("=== Test: Compile Binary Expression Plus ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 5);
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 5);
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *plus_token, right);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(plus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_binary_expression_minus() {
    printf("=== Test: Compile Binary Expression Minus ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 10);
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 5);
    Token* minus_token = token_create(OP_MINUS, "-", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *minus_token, right);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(minus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_binary_expression_mult() {
    printf("=== Test: Compile Binary Expression Multiply ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 3);
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 4);
    Token* star_token = token_create(OP_MULT, "*", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *star_token, right);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(star_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_binary_expression_div() {
    printf("=== Test: Compile Binary Expression Divide ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 15);
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 3);
    Token* slash_token = token_create(OP_DIV, "/", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *slash_token, right);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(slash_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_unary_expression_plus() {
    printf("=== Test: Compile Unary Expression Plus ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* operand = ast_new_literal_expression(loc, TYPE_INT, 5);
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* unary = ast_new_unary_expression(loc, *plus_token, operand);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, unary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Unary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(plus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_unary_expression_minus() {
    printf("=== Test: Compile Unary Expression Minus ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* operand = ast_new_literal_expression(loc, TYPE_INT, 10);
    Token* minus_token = token_create(OP_MINUS, "-", 1, 1);
    ASTNode* unary = ast_new_unary_expression(loc, *minus_token, operand);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, unary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Unary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(minus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_unary_expression_not() {
    printf("=== Test: Compile Unary Expression Not ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* operand = ast_new_literal_expression(loc, TYPE_BOOL, true);
    Token* not_token = token_create(OP_NOT, "not", 1, 1);
    ASTNode* unary = ast_new_unary_expression(loc, *not_token, operand);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, unary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Unary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(not_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_binary_with_unary_left() {
    printf("=== Test: Compile Binary Expression with Unary Left ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    
    ASTNode* unary_operand = ast_new_literal_expression(loc, TYPE_INT, 5);
    Token* minus_token = token_create(OP_MINUS, "-", 1, 1);
    ASTNode* unary_expr = ast_new_unary_expression(loc, *minus_token, unary_operand);
    
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 10);
    
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, unary_expr, *plus_token, right);
    
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary with unary left compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    bool has_load_const = false;
    bool has_unary_op = false;
    bool has_binary_op = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        
        if (bc.op_code == LOAD_CONST) {
            has_load_const = true;
        }
        if (bc.op_code == UNARY_OP) {
            has_unary_op = true;
        }
        if (bc.op_code == BINARY_OP) {
            has_binary_op = true;
        }
    }

    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    assert(has_load_const);
    assert(has_unary_op);
    assert(has_binary_op);
    printf("✓ Contains all expected instructions: LOAD_CONST, UNARY_OP, BINARY_OP\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(minus_token);
    token_free(plus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_binary_with_unary_right() {
    printf("=== Test: Compile Binary Expression with Unary Right ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 8);
    
    ASTNode* unary_operand = ast_new_literal_expression(loc, TYPE_INT, 3);
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* unary_expr = ast_new_unary_expression(loc, *plus_token, unary_operand);
    
    Token* mult_token = token_create(OP_MULT, "*", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *mult_token, unary_expr);
    
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);

    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary with unary right compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(plus_token);
    token_free(mult_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_complex_expression() {
    printf("=== Test: Compile Complex Expression ===\n");
    // not (5 + (-3)) * 2
    
    // Arrange
    SourceLocation loc = {0, 0};
    
    ASTNode* left_inner = ast_new_literal_expression(loc, TYPE_INT, 5);
    
    ASTNode* unary_operand = ast_new_literal_expression(loc, TYPE_INT, 3);
    Token* minus_token = token_create(OP_MINUS, "-", 1, 1);
    ASTNode* unary_expr = ast_new_unary_expression(loc, *minus_token, unary_operand);
    
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* inner_binary = ast_new_binary_expression(loc, left_inner, *plus_token, unary_expr);
    
    Token* not_token = token_create(OP_NOT, "not", 1, 1);
    ASTNode* outer_unary = ast_new_unary_expression(loc, *not_token, inner_binary);
    
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 2);
    
    Token* mult_token = token_create(OP_MULT, "*", 1, 1);
    ASTNode* final_binary = ast_new_binary_expression(loc, outer_unary, *mult_token, right);
    
    ASTNode* expression_stmt = ast_new_expression_statement(loc, final_binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);

    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Complex expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    int load_const_count = 0;
    int unary_op_count = 0;
    int binary_op_count = 0;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        
        if (bc.op_code == LOAD_CONST) load_const_count++;
        if (bc.op_code == UNARY_OP) unary_op_count++;
        if (bc.op_code == BINARY_OP) binary_op_count++;
    }
    
    assert(load_const_count >= 3);
    assert(unary_op_count >= 2);
    assert(binary_op_count >= 2);
    printf("✓ Contains expected instruction counts\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(minus_token);
    token_free(plus_token);
    token_free(not_token);
    token_free(mult_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_function_call() {
    printf("=== Test: Compile Function Call ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};

    Token* token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* initializer = ast_new_binary_expression(
        loc, 
        ast_new_literal_expression(
            loc, 
            TYPE_INT, 
            5), 
        *token,
        ast_new_literal_expression(
            loc, 
            TYPE_INT, 
            6)
    );
    ASTNode* var_decl = ast_new_variable_declaration_statement(loc, TYPE_INT, "x", initializer);
   
    ASTNode* body_statements[] = {var_decl};
    ASTNode* body = ast_new_block_statement(loc, body_statements, 1);
    
    Parameter* param = ast_new_parameter("a", TYPE_INT);
    Parameter* param2 = ast_new_parameter("b", TYPE_INT);
    Parameter* params = malloc(sizeof(Parameter)*2);
    params[0] = *param;
    params[1] = *param2;
    ASTNode* func_decl = ast_new_function_declaration_statement(loc, "add", TYPE_NONE, params, 2, body);
    
    ASTNode* callee = ast_new_variable_expression(loc, "add");
    ASTNode* arg1 = ast_new_literal_expression(loc, TYPE_INT, 5);
    ASTNode* arg2 = ast_new_literal_expression(loc, TYPE_INT, 3);
    ASTNode* arguments[] = {arg1, arg2};
    
    ASTNode* func_call = ast_new_call_expression(loc, callee, arguments, 2);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, func_call);
    ASTNode* statements[] = {func_decl, expression_stmt}; // fix here func decl REDO
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 2);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_global = false;
    bool has_load_const = false;
    bool has_push_null = false;
    bool has_load_fast = false;
    bool has_call_function = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_GLOBAL) has_load_global = true;
        if (bc.op_code == PUSH_NULL) has_push_null = true;
        if (bc.op_code == LOAD_FAST) has_load_fast = true;
        if (bc.op_code == LOAD_CONST) has_load_const = true;
        if (bc.op_code == CALL_FUNCTION) has_call_function = true;
    }
    
    assert(has_load_global || has_load_fast);
    assert(has_push_null);
    assert(has_load_const);
    assert(has_call_function);
    
    printf("✓ Function call compilation completed\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_variable_declaration() {
    printf("=== Test: Compile Variable Declaration ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    Token* token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* initializer = ast_new_binary_expression(
        loc, 
        ast_new_literal_expression(
            loc, 
            TYPE_INT, 
            5), 
        *token,
        ast_new_literal_expression(
            loc, 
            TYPE_INT, 
            6)
    );
    ASTNode* var_decl = ast_new_variable_declaration_statement(loc, TYPE_INT, "x", initializer);
    ASTNode* statements[] = {var_decl};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    bool has_store = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) has_load_const = true;
        if (bc.op_code == STORE_FAST || bc.op_code == STORE_GLOBAL) has_store = true;
    }
    
    assert(has_load_const);
    assert(has_store);
    
    printf("✓ Variable declaration compilation completed\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_variable_declaration_no_initializer() {
    printf("=== Test: Compile Variable Declaration No Initializer ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* var_decl = ast_new_variable_declaration_statement(loc, TYPE_INT, "y", NULL);
    ASTNode* statements[] = {var_decl};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    bool has_store = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) has_load_const = true;
        if (bc.op_code == STORE_FAST || bc.op_code == STORE_GLOBAL) has_store = true;
    }
    
    assert(has_load_const);
    assert(has_store);
    
    printf("✓ Variable declaration without initializer compilation completed\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_function_declaration() {
    printf("=== Test: Compile Function Declaration ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    Token* token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* initializer = ast_new_binary_expression(
        loc, 
        ast_new_literal_expression(
            loc, 
            TYPE_INT, 
            5), 
        *token,
        ast_new_literal_expression(
            loc, 
            TYPE_INT, 
            6)
    );
    ASTNode* var_decl = ast_new_variable_declaration_statement(loc, TYPE_INT, "x", initializer);
   
    ASTNode* body_statements[] = {var_decl};
    ASTNode* body = ast_new_block_statement(loc, body_statements, 1);
    
    Parameter* param = ast_new_parameter("a", TYPE_INT);
    Parameter* params = malloc(sizeof(Parameter));
    params[0] = *param;
    ASTNode* func_decl = ast_new_function_declaration_statement(loc, "test_func", TYPE_NONE, params, 1, body);
    ASTNode* statements[] = {func_decl};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    bytecode_array* arr = &result->constants[3].code_val->code;
    bytecode_array_print(arr);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    assert(comp->global_names != NULL);
    int32_t func_index = string_table_find(comp->global_names, "test_func");
    assert(func_index >= 0);
    
    printf("✓ Function declaration compilation completed\n");
    printf("✓ Function added to global names with index: %d\n", func_index);
    
    // Cleanup
    compiler_destroy(comp);
    //free(params);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_assignment_statement_local() {
    printf("=== Test: Compile Assignment Statement (Local) ===\n");
    
    // Arrange: var x: int = 5; x = 10;
    SourceLocation loc = {0, 0};
    
    // Declare variable first
    // int x = 5
    ASTNode* var_decl = ast_new_variable_declaration_statement(
        loc, 
        TYPE_INT, 
        "x", 
        ast_new_literal_expression(loc, TYPE_INT, 5)
    );

    
    // Assignment statement
    // x = 10
    ASTNode* left = ast_new_variable_expression(loc, "x");
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 10);
    ASTNode* assignment = ast_new_assignment_statement(loc, left, right);

    ASTNode* body_statements[] = {var_decl, assignment};
    ASTNode* body = ast_new_block_statement(loc, body_statements, 1);
    
    // None test_func() { int x = 5; x = 10 }
    ASTNode* func_decl = ast_new_function_declaration_statement(loc, "test_func", TYPE_NONE, NULL, 0, body);

    
    ASTNode* statements[] = {func_decl};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 2);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    bool has_store_fast = false;
    bool has_binary_op = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) has_load_const = true;
        //if (bc.op_code == STORE_FAST) has_store_fast = true;
        if (bc.op_code == BINARY_OP) has_binary_op = true;
    }

    printf("Generated bytecode inside func:\n");
    bytecode_array_print(&result->constants[0].code_val->code);
    for (uint32_t i = 0; i < result->constants[0].code_val->code.count; i++) {
        bytecode bc = result->constants[0].code_val->code.bytecodes[i];
        if (bc.op_code == STORE_FAST) has_store_fast = true;
    }
    
    assert(has_load_const);
    assert(has_store_fast);
    printf("✓ Local assignment uses STORE_FAST\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_assignment_statement_global() {
    printf("=== Test: Compile Assignment Statement (Global) ===\n");
    
    // Arrange: x = 10; (without declaration - should be global)
    SourceLocation loc = {0, 0};
    
    // Assignment statement to undeclared variable (should become global)
    ASTNode* left = ast_new_variable_expression(loc, "global_var");
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 42);
    ASTNode* assignment = ast_new_assignment_statement(loc, left, right);
    
    ASTNode* statements[] = {assignment};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    bool has_store_global = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) has_load_const = true;
        if (bc.op_code == STORE_GLOBAL) has_store_global = true;
    }
    
    assert(has_load_const);
    assert(has_store_global);
    printf("✓ Global assignment uses STORE_GLOBAL\n");
    
    // Verify variable was added to global names
    assert(comp->global_names != NULL);
    int32_t global_index = string_table_find(comp->global_names, "global_var");
    assert(global_index >= 0);
    printf("✓ Variable added to global names with index: %d\n", global_index);
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_assignment_statement_with_expression() {
    printf("=== Test: Compile Assignment Statement with Expression ===\n");
    
    // Arrange: x = 5 + 3 * 2
    SourceLocation loc = {0, 0};
    
    // Declare variable first
    ASTNode* var_decl = ast_new_variable_declaration_statement(
        loc, 
        TYPE_INT, 
        "result", 
        ast_new_literal_expression(loc, TYPE_INT, 0)
    );
    
    // Create expression: 5 + 3 * 2
    ASTNode* mult_left = ast_new_literal_expression(loc, TYPE_INT, 3);
    ASTNode* mult_right = ast_new_literal_expression(loc, TYPE_INT, 2);
    Token* mult_token = token_create(OP_MULT, "*", 1, 1);
    ASTNode* multiplication = ast_new_binary_expression(loc, mult_left, *mult_token, mult_right);
    
    ASTNode* add_left = ast_new_literal_expression(loc, TYPE_INT, 5);
    Token* add_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* addition = ast_new_binary_expression(loc, add_left, *add_token, multiplication);
    
    // Assignment statement
    ASTNode* left = ast_new_variable_expression(loc, "result");
    ASTNode* assignment = ast_new_assignment_statement(loc, left, addition);
    
    ASTNode* statements[] = {var_decl, assignment};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 2);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    int load_const_count = 0;
    bool has_binary_op = false;
    bool has_store = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) load_const_count++;
        if (bc.op_code == BINARY_OP) has_binary_op = true;
        if (bc.op_code == STORE_FAST || bc.op_code == STORE_GLOBAL) has_store = true;
    }
    
    assert(load_const_count >= 3); // Should have constants for 5, 3, 2
    assert(has_binary_op);
    assert(has_store);
    printf("✓ Assignment with complex expression compiled correctly\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(mult_token);
    token_free(add_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_assignment_statement_boolean() {
    printf("=== Test: Compile Assignment Statement (Boolean) ===\n");
    
    // Arrange: var flag: bool = true; flag = false;
    SourceLocation loc = {0, 0};
    
    // Declare boolean variable
    ASTNode* var_decl = ast_new_variable_declaration_statement(
        loc, 
        TYPE_BOOL, 
        "flag", 
        ast_new_literal_expression(loc, TYPE_BOOL, 1)
    );

    // flag = true
    // flag = false
    
    // Assignment statement with boolean
    ASTNode* left = ast_new_variable_expression(loc, "flag");
    ASTNode* right = ast_new_literal_expression(loc, TYPE_BOOL, 0);
    ASTNode* assignment = ast_new_assignment_statement(loc, left, right);
    
    ASTNode* statements[] = {var_decl, assignment};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 2);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_bool_const = false;
    bool has_store_global = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            uint32_t const_index = bytecode_get_arg(bc);
            if (const_index < result->constants_count && 
                result->constants[const_index].type == VAL_BOOL) {
                has_bool_const = true;
            }
        }
        if (bc.op_code == STORE_GLOBAL) has_store_global = true;
    }
    
    assert(has_bool_const);
    //assert(has_store_global);
    printf("✓ Boolean assignment compiled correctly\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_assignment_statement_reassign_global() {
    printf("=== Test: Compile Assignment Statement (Reassign Global) ===\n");
    
    // Arrange: 
    // x = 5;  // global declaration
    // x = 10; // reassignment
    SourceLocation loc = {0, 0};
    
    // First assignment (declares global)
    ASTNode* left1 = ast_new_variable_expression(loc, "counter");
    ASTNode* right1 = ast_new_literal_expression(loc, TYPE_INT, 5);
    ASTNode* assignment1 = ast_new_assignment_statement(loc, left1, right1);
    
    // Second assignment (reassigns existing global)
    ASTNode* left2 = ast_new_variable_expression(loc, "counter");
    ASTNode* right2 = ast_new_literal_expression(loc, TYPE_INT, 10);
    ASTNode* assignment2 = ast_new_assignment_statement(loc, left2, right2);
    
    ASTNode* statements[] = {assignment1, assignment2};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 2);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    int store_global_count = 0;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == STORE_GLOBAL) {
            store_global_count++;
        }
    }
    
    assert(store_global_count == 2);
    printf("✓ Global variable reassignment compiled correctly\n");
    
    // Verify variable exists in global names
    assert(comp->global_names != NULL);
    int32_t global_index = string_table_find(comp->global_names, "counter");
    assert(global_index >= 0);
    printf("✓ Global variable found with index: %d\n", global_index);
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_assignment_statement_with_function_call() {
    printf("=== Test: Compile Assignment Statement with Function Call ===\n");
    
    // Arrange: result = add(5, 3)
    SourceLocation loc = {0, 0};
    
    // Create a simple function declaration first
    Parameter* param1 = ast_new_parameter("a", TYPE_INT);
    Parameter* param2 = ast_new_parameter("b", TYPE_INT);
    Parameter* params = malloc(sizeof(Parameter) * 2);
    params[0] = *param1;
    params[1] = *param2;
    
    // Function body: return a + b
    ASTNode* return_expr = ast_new_binary_expression(
        loc,
        ast_new_variable_expression(loc, "a"),
        *token_create(OP_PLUS, "+", 1, 1),
        ast_new_variable_expression(loc, "b")
    );
    ASTNode* return_stmt = ast_new_return_statement(loc, return_expr);
    ASTNode* body_stmts[] = {return_stmt};
    ASTNode* body = ast_new_block_statement(loc, body_stmts, 1);
    
    ASTNode* func_decl = ast_new_function_declaration_statement(
        loc, "add", TYPE_INT, params, 2, body
    );
    
    // Assignment with function call
    ASTNode* callee = ast_new_variable_expression(loc, "add");
    ASTNode* arg1 = ast_new_literal_expression(loc, TYPE_INT, 5);
    ASTNode* arg2 = ast_new_literal_expression(loc, TYPE_INT, 3);
    ASTNode* args[] = {arg1, arg2};
    ASTNode* func_call = ast_new_call_expression(loc, callee, args, 2);
    
    ASTNode* left = ast_new_variable_expression(loc, "result");
    ASTNode* assignment = ast_new_assignment_statement(loc, left, func_call);
    
    ASTNode* statements[] = {func_decl, assignment};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 2);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_call_function = false;
    bool has_store = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == CALL_FUNCTION) has_call_function = true;
        if (bc.op_code == STORE_GLOBAL) has_store = true;
    }
    
    assert(has_call_function);
    assert(has_store);
    printf("✓ Assignment with function call compiled correctly\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_simple_assignment() {
    printf("=== Simple Assignment Test ===\n");
    
    SourceLocation loc = {0, 0};
    
    // Простое присваивание: x = 5
    ASTNode* left = ast_new_variable_expression(loc, "x");
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 5);
    ASTNode* assignment = ast_new_assignment_statement(loc, left, right);
    
    ASTNode* statements[] = {assignment};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    
    printf("Creating compiler...\n");
    compiler* comp = compiler_create(block_stmt);
    assert(comp != NULL);
    
    printf("Compiling...\n");
    compilation_result* result = compiler_compile(comp);
    
    printf("Compilation finished\n");
    if (result) {
        printf("Generated %u bytecodes\n", result->code_array.count);
    }
    compiler_destroy(comp);
    printf("Test finished\n\n");
}

void test_compile_float_literal_expression() {
    printf("=== Test: Compile Float Literal Expression ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* literal = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "3.14159");
    ASTNode* expression_stmt = ast_new_expression_statement(loc, literal);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.count > 0);
    assert(result->code_array.bytecodes != NULL);
    assert(result->constants_count > 0);
    printf("✓ Float literal compilation completed successfully\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    printf("✓ Constants pool size: %zu\n", result->constants_count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            has_load_const = true;
            uint32_t const_index = bytecode_get_arg(bc);
            printf("  LOAD_CONST found with const_index=%u\n", const_index);
            assert(const_index < result->constants_count);
        }
    }
    
    assert(has_load_const);
    printf("✓ Contains LOAD_CONST instruction\n");
    
    assert(result->constants_count >= 1);
    assert(result->constants[0].type == VAL_FLOAT);
    // Проверяем строковое значение для float (long arithmetic)
    printf("✓ Float constant created with long arithmetic\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_float_declaration() {
    printf("=== Test: Compile Float Declaration ===\n");
    
    // Arrange: float pi = 3.14159;
    SourceLocation loc = {0, 0};
    ASTNode* initializer = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "3.14159");
    ASTNode* var_decl = ast_new_variable_declaration_statement(loc, TYPE_FLOAT, "pi", initializer);
    ASTNode* statements[] = {var_decl};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    bool has_store = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            has_load_const = true;
            uint32_t const_index = bytecode_get_arg(bc);
            if (const_index < result->constants_count) {
                assert(result->constants[const_index].type == VAL_FLOAT);
            }
        }
        if (bc.op_code == STORE_FAST || bc.op_code == STORE_GLOBAL) {
            has_store = true;
        }
    }
    
    assert(has_load_const);
    assert(has_store);
    printf("✓ Float declaration compilation completed\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_float_binary_expression() {
    printf("=== Test: Compile Float Binary Expression ===\n");
    
    // Arrange: 2.5 + 1.5
    SourceLocation loc = {0, 0};
    ASTNode* left = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "2.5");
    ASTNode* right = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "1.5");
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *plus_token, right);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Float binary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    int load_const_count = 0;
    bool has_binary_op = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            load_const_count++;
            uint32_t const_index = bytecode_get_arg(bc);
            if (const_index < result->constants_count) {
                assert(result->constants[const_index].type == VAL_FLOAT);
            }
        }
        if (bc.op_code == BINARY_OP) {
            has_binary_op = true;
        }
    }
    
    assert(load_const_count >= 2);
    assert(has_binary_op);
    printf("✓ Float binary expression contains correct instructions\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(plus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_float_mixed_expression() {
    printf("=== Test: Compile Mixed Int/Float Expression ===\n");
    
    // Arrange: 3 * 2.5 (int * float)
    SourceLocation loc = {0, 0};
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 3);
    ASTNode* right = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "2.5");
    Token* mult_token = token_create(OP_MULT, "*", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *mult_token, right);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Mixed int/float expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_int_const = false;
    bool has_float_const = false;
    bool has_binary_op = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            uint32_t const_index = bytecode_get_arg(bc);
            if (const_index < result->constants_count) {
                if (result->constants[const_index].type == VAL_INT) {
                    has_int_const = true;
                    assert(result->constants[const_index].int_val == 3);
                } else if (result->constants[const_index].type == VAL_FLOAT) {
                    has_float_const = true;
                }
            }
        }
        if (bc.op_code == BINARY_OP) {
            has_binary_op = true;
        }
    }
    
    assert(has_int_const);
    assert(has_float_const);
    assert(has_binary_op);
    printf("✓ Mixed expression contains both int and float constants\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(mult_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_float_complex_expression() {
    printf("=== Test: Compile Complex Float Expression ===\n");
    
    // Arrange: (3.14 + 2.0) * 4.5 / 2.0
    SourceLocation loc = {0, 0};
    
    // 3.14 + 2.0
    ASTNode* left_add = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "3.14");
    ASTNode* right_add = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "2.0");
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* addition = ast_new_binary_expression(loc, left_add, *plus_token, right_add);
    
    // * 4.5
    ASTNode* mult_right = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "4.5");
    Token* mult_token = token_create(OP_MULT, "*", 1, 1);
    ASTNode* multiplication = ast_new_binary_expression(loc, addition, *mult_token, mult_right);
    
    // / 2.0
    ASTNode* div_right = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "2.0");
    Token* div_token = token_create(OP_DIV, "/", 1, 1);
    ASTNode* division = ast_new_binary_expression(loc, multiplication, *div_token, div_right);
    
    ASTNode* expression_stmt = ast_new_expression_statement(loc, division);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Complex float expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    int load_const_count = 0;
    int binary_op_count = 0;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            load_const_count++;
            uint32_t const_index = bytecode_get_arg(bc);
            if (const_index < result->constants_count) {
                assert(result->constants[const_index].type == VAL_FLOAT);
            }
        }
        if (bc.op_code == BINARY_OP) {
            binary_op_count++;
        }
    }
    
    assert(load_const_count >= 4); // 3.14, 2.0, 4.5, 2.0
    assert(binary_op_count >= 3);  // +, *, /
    printf("✓ Complex float expression contains correct instruction counts\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(plus_token);
    token_free(mult_token);
    token_free(div_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_float_unary_expression() {
    printf("=== Test: Compile Float Unary Expression ===\n");
    
    // Arrange: -3.14
    SourceLocation loc = {0, 0};
    ASTNode* operand = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "3.14");
    Token* minus_token = token_create(OP_MINUS, "-", 1, 1);
    ASTNode* unary = ast_new_unary_expression(loc, *minus_token, operand);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, unary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Float unary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    bool has_unary_op = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            has_load_const = true;
            uint32_t const_index = bytecode_get_arg(bc);
            if (const_index < result->constants_count) {
                assert(result->constants[const_index].type == VAL_FLOAT);
            }
        }
        if (bc.op_code == UNARY_OP) {
            has_unary_op = true;
        }
    }
    
    assert(has_load_const);
    assert(has_unary_op);
    printf("✓ Float unary expression contains correct instructions\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(minus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_float_scientific_notation() {
    printf("=== Test: Compile Float Scientific Notation ===\n");
    
    // Arrange: 1.23e-4 (scientific notation)
    SourceLocation loc = {0, 0};
    ASTNode* literal = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "1.23e-4");
    ASTNode* expression_stmt = ast_new_expression_statement(loc, literal);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.count > 0);
    assert(result->code_array.bytecodes != NULL);
    printf("✓ Scientific notation float compilation completed successfully\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            has_load_const = true;
            uint32_t const_index = bytecode_get_arg(bc);
            printf("  LOAD_CONST found with const_index=%u\n", const_index);
            assert(const_index < result->constants_count);
            if (const_index < result->constants_count) {
                assert(result->constants[const_index].type == VAL_FLOAT);
                // Проверяем что строка содержит научную нотацию
                printf("  Float value stored as: scientific notation\n");
            }
        }
    }
    
    assert(has_load_const);
    printf("✓ Scientific notation float contains LOAD_CONST instruction\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_float_assignment() {
    printf("=== Test: Compile Float Assignment ===\n");
    
    // Arrange: float result = 2.5 * 3.0;
    SourceLocation loc = {0, 0};
    
    // Создаем выражение 2.5 * 3.0
    ASTNode* left = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "2.5");
    ASTNode* right = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "3.0");
    Token* mult_token = token_create(OP_MULT, "*", 1, 1);
    ASTNode* expression = ast_new_binary_expression(loc, left, *mult_token, right);
    
    // Объявление переменной с инициализацией
    ASTNode* var_decl = ast_new_variable_declaration_statement(loc, TYPE_FLOAT, "result", expression);
    
    ASTNode* statements[] = {var_decl};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    int float_const_count = 0;
    bool has_binary_op = false;
    bool has_store = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            uint32_t const_index = bytecode_get_arg(bc);
            if (const_index < result->constants_count && 
                result->constants[const_index].type == VAL_FLOAT) {
                float_const_count++;
            }
        }
        if (bc.op_code == BINARY_OP) has_binary_op = true;
        if (bc.op_code == STORE_FAST || bc.op_code == STORE_GLOBAL) has_store = true;
    }
    
    assert(float_const_count >= 2);
    assert(has_binary_op);
    assert(has_store);
    printf("✓ Float assignment with expression compiled correctly\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(mult_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_float_function_parameter() {
    printf("=== Test: Compile Function with Float Parameter ===\n");
    
    // Arrange: float calculate(float radius) { return 3.14 * radius * radius; }
    SourceLocation loc = {0, 0};
    
    // Создаем выражение: 3.14 * radius * radius
    ASTNode* pi = ast_new_literal_expression_long_arithmetics(loc, TYPE_FLOAT, "3.14");
    ASTNode* radius_var = ast_new_variable_expression(loc, "radius");
    
    Token* mult_token1 = token_create(OP_MULT, "*", 1, 1);
    ASTNode* first_mult = ast_new_binary_expression(loc, pi, *mult_token1, radius_var);
    
    Token* mult_token2 = token_create(OP_MULT, "*", 1, 1);
    ASTNode* second_mult = ast_new_binary_expression(loc, first_mult, *mult_token2, radius_var);
    
    ASTNode* return_stmt = ast_new_return_statement(loc, second_mult);
    ASTNode* body_stmts[] = {return_stmt};
    ASTNode* body = ast_new_block_statement(loc, body_stmts, 1);
    
    Parameter* param = ast_new_parameter("radius", TYPE_FLOAT);
    Parameter* params = malloc(sizeof(Parameter));
    params[0] = *param;
    
    ASTNode* func_decl = ast_new_function_declaration_statement(
        loc, "calculate_area", TYPE_FLOAT, params, 1, body
    );
    
    ASTNode* statements[] = {func_decl};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_float_const = false;
    
    // Проверяем константы в основном результате
    for (uint32_t i = 0; i < result->constants_count; i++) {
        if (result->constants[i].type == VAL_CODE) {
            // Это CodeObj функции - проверяем его константы
            CodeObj* code_obj = result->constants[i].code_val;
            printf("Found CodeObj for function: %s\n", code_obj->name);
            printf("Function has %zu constants\n", code_obj->constants_count);
            
            // Выводим байткод функции
            printf("Function bytecode:\n");
            bytecode_array_print(&code_obj->code);
            
            // Проверяем константы функции
            for (size_t j = 0; j < code_obj->constants_count; j++) {
                if (code_obj->constants[j].type == VAL_FLOAT) {
                    has_float_const = true;
                    printf("✓ Found float constant in function: %s\n", code_obj->constants[j].float_val);
                }
            }
        }
    }
    
    assert(has_float_const);
    printf("✓ Function with float parameter compiled correctly\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(mult_token1);
    token_free(mult_token2);
    printf("✓ Test completed successfully\n\n");
}

// gcc tests/compiler/test_compiler.c src/compiler/compiler.c src/compiler/value.c src/compiler/scope.c src/compiler/string_table.c src/compiler/bytecode.c src/AST/ast.c src/lexer/token.c
int main() {
    debug_enabled = 1;
    printf("Starting Compiler Tests...\n\n");
    test_compiler_creation_and_destruction();
    test_compile_literal_expression();
    test_compile_bool_literal();
    test_compile_empty_block();
    test_null_safety();
    test_bytecode_integrity();
    test_compile_variable_expression_no_such_var();
    test_compile_variable_expression(); //todo
    test_compile_binary_expression_plus();
    test_compile_binary_expression_minus();
    test_compile_binary_expression_mult();
    test_compile_binary_expression_div();
    test_compile_unary_expression_plus();
    test_compile_unary_expression_minus();
    test_compile_unary_expression_not();
    test_compile_binary_with_unary_left();
    test_compile_binary_with_unary_right();
    test_compile_complex_expression();
    test_compile_function_call(); 
    test_compile_variable_declaration();
    test_compile_variable_declaration_no_initializer();
    test_compile_function_declaration();
    test_compile_assignment_statement_boolean();
    test_compile_assignment_statement_reassign_global();
    test_compile_assignment_statement_with_function_call();
    test_compile_assignment_statement_local();
    test_compile_assignment_statement_global();
    test_simple_assignment();
    test_compile_assignment_statement_with_expression();

    test_compile_float_literal_expression();
    test_compile_float_declaration();
    test_compile_float_binary_expression();
    test_compile_float_mixed_expression();
    test_compile_float_complex_expression();
    test_compile_float_unary_expression();
    test_compile_float_scientific_notation();
    test_compile_float_assignment();
    test_compile_float_function_parameter();

    printf("All tests passed! ✅\n");
    return 0;
}
