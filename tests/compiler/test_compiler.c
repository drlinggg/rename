#include "../../src/compiler/compiler.h"
#include "../../src/AST/ast.h"
#include "../../src/lexer/token.h"
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

void test_compiler_creation_and_destruction() {
    printf("=== Test: Compiler Creation and Destruction ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* literal = ast_new_literal_expression(loc, TYPE_INT, 5);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, literal);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    
    // Act
    compiler* comp = compiler_create(block_stmt);
    
    // Assert
    assert(comp != NULL);
    assert(comp->ast_tree == block_stmt);
    assert(comp->result != NULL);
    assert(comp->result->code_array.bytecodes == NULL);
    assert(comp->result->code_array.count == 0);
    assert(comp->result->code_array.capacity == 0);
    printf("✓ Compiler created successfully\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Compiler destroyed successfully\n\n");
}

void test_compile_literal_expression() {
    printf("=== Test: Compile Literal Expression ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* literal = ast_new_literal_expression(loc, TYPE_INT, 42);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, literal);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.count > 0);
    assert(result->code_array.bytecodes != NULL);
    assert(result->constants_count > 0);
    printf("✓ Compilation completed successfully\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    printf("✓ Constants pool size: %zu\n", result->constants_count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            has_load_const = true;
            uint32_t const_index = bytecode_get_arg(bc);
            printf("  LOAD_CONST found with const_index=%u\n", const_index);
            assert(const_index < result->constants_count);
        }
    }
    
    assert(has_load_const);
    printf("✓ Contains LOAD_CONST instruction\n");
    
    assert(result->constants_count >= 1);
    assert(result->constants[0].type == VAL_INT);
    assert(result->constants[0].int_val == 42);
    printf("✓ Constant value is correct: %lld\n", result->constants[0].int_val);
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_bool_literal() {
    printf("=== Test: Compile Bool Literal ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* literal = ast_new_literal_expression(loc, TYPE_BOOL, true);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, literal);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->constants_count >= 1);
    assert(result->constants[0].type == VAL_BOOL);
    assert(result->constants[0].bool_val == true);
    printf("✓ Boolean constant value is correct: %s\n", 
           result->constants[0].bool_val ? "true" : "false");
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) {
            has_load_const = true;
            uint32_t const_index = bytecode_get_arg(bc);
            assert(const_index < result->constants_count);
            assert(result->constants[const_index].type == VAL_BOOL);
            assert(result->constants[const_index].bool_val == true);
        }
    }
    assert(has_load_const);
    printf("✓ Contains correct LOAD_CONST instruction for boolean\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_empty_block() {
    printf("=== Test: Compile Empty Block ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* statements[] = {};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 0);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    printf("✓ Empty block compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    printf("✓ Constants pool size: %zu\n", result->constants_count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    if (result->code_array.count == 0) {
        printf("✓ No bytecode generated (as expected for empty block)\n");
    }
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_null_safety() {
    printf("=== Test: Null Safety ===\n");
    
    // Act & Assert
    compiler* null_comp = compiler_create(NULL);
    assert(null_comp == NULL);
    printf("✓ compiler_create(NULL) returns NULL\n");
    
    compiler_destroy(NULL);
    printf("✓ compiler_destroy(NULL) is safe\n");
    
    compilation_result* null_result = compiler_compile(NULL);
    assert(null_result == NULL);
    printf("✓ compiler_compile(NULL) returns NULL\n");
    
    printf("✓ Null safety test completed successfully\n\n");
}

void test_bytecode_integrity() {
    printf("=== Test: Bytecode Integrity ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* literal = ast_new_literal_expression(loc, TYPE_INT, 123);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, literal);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        printf("  Bytecode[%u]: op_code=%u\n", i, bc.op_code);
        
        assert(bc.op_code <= 255);
        assert(bc.op_code == LOAD_CONST);
    }
    
    printf("✓ All bytecode instructions have valid op_codes\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Bytecode integrity test completed successfully\n\n");
}

void test_compile_variable_expression_no_such_var(){
    printf("=== Test: compile variable expr no such var ===\n");
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* variable = ast_new_variable_expression(loc, "x");
    ASTNode* expression_stmt = ast_new_expression_statement(loc, variable);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);

    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.bytecodes[0].op_code == NOP);

    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ compile variable expr test completed successfully\n\n");
}

void test_compile_variable_expression(){
    printf("=== Test: compile variable expr ===\n");
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* assign = ast_new_variable_declaration_statement(loc, TYPE_INT, "x", ast_new_literal_expression(loc, TYPE_INT, 5));

    ASTNode* variable = ast_new_variable_expression(loc, "x");
    ASTNode* expression_stmt = ast_new_expression_statement(loc, variable);

    ASTNode* statements[] = {assign, expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 2);
    compiler* comp = compiler_create(block_stmt);

    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 1);
    assert(result->code_array.bytecodes[0].op_code == NOP);

    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ compile variable expr test completed successfully\n\n");
}

void test_compile_binary_expression_plus() {
    printf("=== Test: Compile Binary Expression Plus ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 5);
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 5);
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *plus_token, right);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(plus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_binary_expression_minus() {
    printf("=== Test: Compile Binary Expression Minus ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 10);
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 5);
    Token* minus_token = token_create(OP_MINUS, "-", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *minus_token, right);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(minus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_binary_expression_mult() {
    printf("=== Test: Compile Binary Expression Multiply ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 3);
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 4);
    Token* star_token = token_create(OP_MULT, "*", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *star_token, right);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(star_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_binary_expression_div() {
    printf("=== Test: Compile Binary Expression Divide ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 15);
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 3);
    Token* slash_token = token_create(OP_DIV, "/", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *slash_token, right);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(slash_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_unary_expression_plus() {
    printf("=== Test: Compile Unary Expression Plus ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* operand = ast_new_literal_expression(loc, TYPE_INT, 5);
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* unary = ast_new_unary_expression(loc, *plus_token, operand);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, unary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Unary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(plus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_unary_expression_minus() {
    printf("=== Test: Compile Unary Expression Minus ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* operand = ast_new_literal_expression(loc, TYPE_INT, 10);
    Token* minus_token = token_create(OP_MINUS, "-", 1, 1);
    ASTNode* unary = ast_new_unary_expression(loc, *minus_token, operand);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, unary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Unary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Вывод сгенерированного байткода
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(minus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_unary_expression_not() {
    printf("=== Test: Compile Unary Expression Not ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* operand = ast_new_literal_expression(loc, TYPE_BOOL, true);
    Token* not_token = token_create(OP_NOT, "not", 1, 1);
    ASTNode* unary = ast_new_unary_expression(loc, *not_token, operand);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, unary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Unary expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(not_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_binary_with_unary_left() {
    printf("=== Test: Compile Binary Expression with Unary Left ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    
    ASTNode* unary_operand = ast_new_literal_expression(loc, TYPE_INT, 5);
    Token* minus_token = token_create(OP_MINUS, "-", 1, 1);
    ASTNode* unary_expr = ast_new_unary_expression(loc, *minus_token, unary_operand);
    
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 10);
    
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, unary_expr, *plus_token, right);
    
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary with unary left compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    bool has_load_const = false;
    bool has_unary_op = false;
    bool has_binary_op = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        
        if (bc.op_code == LOAD_CONST) {
            has_load_const = true;
        }
        if (bc.op_code == UNARY_OP) {
            has_unary_op = true;
        }
        if (bc.op_code == BINARY_OP) {
            has_binary_op = true;
        }
    }

    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    assert(has_load_const);
    assert(has_unary_op);
    assert(has_binary_op);
    printf("✓ Contains all expected instructions: LOAD_CONST, UNARY_OP, BINARY_OP\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(minus_token);
    token_free(plus_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_binary_with_unary_right() {
    printf("=== Test: Compile Binary Expression with Unary Right ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    
    ASTNode* left = ast_new_literal_expression(loc, TYPE_INT, 8);
    
    ASTNode* unary_operand = ast_new_literal_expression(loc, TYPE_INT, 3);
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* unary_expr = ast_new_unary_expression(loc, *plus_token, unary_operand);
    
    Token* mult_token = token_create(OP_MULT, "*", 1, 1);
    ASTNode* binary = ast_new_binary_expression(loc, left, *mult_token, unary_expr);
    
    ASTNode* expression_stmt = ast_new_expression_statement(loc, binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);

    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Binary with unary right compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    // Cleanup
    compiler_destroy(comp);
    token_free(plus_token);
    token_free(mult_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_complex_expression() {
    printf("=== Test: Compile Complex Expression ===\n");
    // not (5 + (-3)) * 2
    
    // Arrange
    SourceLocation loc = {0, 0};
    
    ASTNode* left_inner = ast_new_literal_expression(loc, TYPE_INT, 5);
    
    ASTNode* unary_operand = ast_new_literal_expression(loc, TYPE_INT, 3);
    Token* minus_token = token_create(OP_MINUS, "-", 1, 1);
    ASTNode* unary_expr = ast_new_unary_expression(loc, *minus_token, unary_operand);
    
    Token* plus_token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* inner_binary = ast_new_binary_expression(loc, left_inner, *plus_token, unary_expr);
    
    Token* not_token = token_create(OP_NOT, "not", 1, 1);
    ASTNode* outer_unary = ast_new_unary_expression(loc, *not_token, inner_binary);
    
    ASTNode* right = ast_new_literal_expression(loc, TYPE_INT, 2);
    
    Token* mult_token = token_create(OP_MULT, "*", 1, 1);
    ASTNode* final_binary = ast_new_binary_expression(loc, outer_unary, *mult_token, right);
    
    ASTNode* expression_stmt = ast_new_expression_statement(loc, final_binary);
    ASTNode* statements[] = {expression_stmt};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);

    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    printf("✓ Complex expression compilation completed\n");
    printf("✓ Generated %u bytecode instructions\n", result->code_array.count);
    
    int load_const_count = 0;
    int unary_op_count = 0;
    int binary_op_count = 0;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        
        if (bc.op_code == LOAD_CONST) load_const_count++;
        if (bc.op_code == UNARY_OP) unary_op_count++;
        if (bc.op_code == BINARY_OP) binary_op_count++;
    }
    
    assert(load_const_count >= 3);
    assert(unary_op_count >= 2);
    assert(binary_op_count >= 2);
    printf("✓ Contains expected instruction counts\n");
    
    // Cleanup
    compiler_destroy(comp);
    token_free(minus_token);
    token_free(plus_token);
    token_free(not_token);
    token_free(mult_token);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_function_call() {
    printf("=== Test: Compile Function Call ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    
    // Создаем вызов функции: add(5, 3)
    ASTNode* callee = ast_new_variable_expression(loc, "add");
    
    ASTNode* arg1 = ast_new_literal_expression(loc, TYPE_INT, 5);
    ASTNode* arg2 = ast_new_literal_expression(loc, TYPE_INT, 3);
    ASTNode* arguments[] = {arg1, arg2};
    
    ASTNode* func_call = ast_new_call_expression(loc, callee, arguments, 2);
    ASTNode* expression_stmt = ast_new_expression_statement(loc, func_call);
    ASTNode* statements[] = {ast_new_expression_statement(loc, callee), expression_stmt}; // fix here func decl
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 2);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_global = false;
    bool has_load_const = false;
    bool has_push_null = false;
    bool has_load_fast = false;
    bool has_call_function = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_GLOBAL) has_load_global = true;
        if (bc.op_code == PUSH_NULL) has_push_null = true;
        if (bc.op_code == LOAD_FAST) has_load_fast = true;
        if (bc.op_code == LOAD_CONST) has_load_const = true;
        if (bc.op_code == CALL_FUNCTION) has_call_function = true;
    }
    
    assert(has_load_global || has_load_fast);
    assert(has_push_null);
    assert(has_load_const);
    assert(has_call_function);
    
    printf("✓ Function call compilation completed\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_variable_declaration() {
    printf("=== Test: Compile Variable Declaration ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    Token* token = token_create(OP_PLUS, "+", 1, 1);
    ASTNode* initializer = ast_new_binary_expression(
        loc, 
        ast_new_literal_expression(
            loc, 
            TYPE_INT, 
            5), 
        *token,
        ast_new_literal_expression(
            loc, 
            TYPE_INT, 
            6)
    );
    ASTNode* var_decl = ast_new_variable_declaration_statement(loc, TYPE_INT, "x", initializer);
    ASTNode* statements[] = {var_decl};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    bool has_store = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) has_load_const = true;
        if (bc.op_code == STORE_FAST || bc.op_code == STORE_GLOBAL) has_store = true;
    }
    
    assert(has_load_const);
    assert(has_store);
    
    printf("✓ Variable declaration compilation completed\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_variable_declaration_no_initializer() {
    printf("=== Test: Compile Variable Declaration No Initializer ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    ASTNode* var_decl = ast_new_variable_declaration_statement(loc, TYPE_INT, "y", NULL);
    ASTNode* statements[] = {var_decl};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    assert(result->code_array.count > 0);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    bool has_load_const = false;
    bool has_store = false;
    
    for (uint32_t i = 0; i < result->code_array.count; i++) {
        bytecode bc = result->code_array.bytecodes[i];
        if (bc.op_code == LOAD_CONST) has_load_const = true;
        if (bc.op_code == STORE_FAST || bc.op_code == STORE_GLOBAL) has_store = true;
    }
    
    assert(has_load_const);
    assert(has_store);
    
    printf("✓ Variable declaration without initializer compilation completed\n");
    
    // Cleanup
    compiler_destroy(comp);
    printf("✓ Test completed successfully\n\n");
}

void test_compile_function_declaration() {
    printf("=== Test: Compile Function Declaration ===\n");
    
    // Arrange
    SourceLocation loc = {0, 0};
    
    ASTNode* body_statements[] = {};
    ASTNode* body = ast_new_block_statement(loc, body_statements, 0);
    
    Parameter* param = ast_new_parameter("a", TYPE_INT);
    Parameter* params = malloc(sizeof(Parameter));
    params[0] = *param;
    ASTNode* func_decl = ast_new_function_declaration_statement(loc, "test_func", TYPE_NONE, params, 1, body);
    ASTNode* statements[] = {func_decl};
    ASTNode* block_stmt = ast_new_block_statement(loc, statements, 1);
    compiler* comp = compiler_create(block_stmt);
    
    // Act
    compilation_result* result = compiler_compile(comp);
    
    // Assert
    assert(result != NULL);
    assert(result->code_array.bytecodes != NULL);
    
    printf("Generated bytecode:\n");
    bytecode_array_print(&result->code_array);
    
    assert(comp->global_names != NULL);
    int32_t func_index = string_table_find(comp->global_names, "test_func");
    assert(func_index >= 0);
    
    printf("✓ Function declaration compilation completed\n");
    printf("✓ Function added to global names with index: %d\n", func_index);
    
    // Cleanup
    compiler_destroy(comp);
    free(params);
    printf("✓ Test completed successfully\n\n");
}

// gcc tests/compiler/test_compiler.c src/compiler/compiler.c src/compiler/value.c src/compiler/scope.c src/compiler/string_table.c src/compiler/bytecode.c src/AST/ast.c src/lexer/token.c
int main() {
    printf("Starting Compiler Tests...\n\n");
    
    test_compiler_creation_and_destruction();
    test_compile_literal_expression();
    test_compile_bool_literal();
    test_compile_empty_block();
    test_null_safety();
    test_bytecode_integrity();
    test_compile_variable_expression_no_such_var();
    //test_compile_variable_expression(); todo
    test_compile_binary_expression_plus();
    test_compile_binary_expression_minus();
    test_compile_binary_expression_mult();
    test_compile_binary_expression_div();
    test_compile_unary_expression_plus();
    test_compile_unary_expression_minus();
    test_compile_unary_expression_not();
    test_compile_binary_with_unary_left();
    test_compile_binary_with_unary_right();
    test_compile_complex_expression();
    // test_compile_function_call(); todo
    test_compile_variable_declaration();
    test_compile_variable_declaration_no_initializer();
    test_compile_function_declaration();
    printf("All tests passed! ✅\n");
    return 0;
}
